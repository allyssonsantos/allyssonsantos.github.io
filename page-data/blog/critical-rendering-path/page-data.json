{
    "componentChunkName": "component---src-templates-blog-post-jsx",
    "path": "/blog/critical-rendering-path/",
    "result": {"data":{"site":{"siteMetadata":{"title":"allysson.me","author":"Allysson Santos"}},"mdx":{"id":"d2ba23c5-2015-567a-b916-56fab03d40b4","slug":"critical-rendering-path/","frontmatter":{"title":"Critical rendering path - Renderização no browser.","date":"17/06/2017","description":"Como o browser renderiza? quais os passos que ele segue até exibir a página na tela?","img":null},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Critical rendering path - Renderização no browser.\",\n  \"slug\": \"/critical-rendering-path\",\n  \"description\": \"Como o browser renderiza? quais os passos que ele segue até exibir a página na tela?\",\n  \"date\": \"2017-06-17\",\n  \"tags\": [\"Web\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Caminho cr\\xEDtico de renderiza\\xE7\\xE3o\"), mdx(\"p\", null, \"O caminho cr\\xEDtico de renderiza\\xE7\\xE3o \\xE9 a sequ\\xEAncia de etapas que o navegador executa para converter o HTML, CSS e Javascript em pixels na tela.\\nVamos conhecer essas etapas e como podemos renderizar as nossas p\\xE1ginas mais r\\xE1pido.\"), mdx(\"p\", null, \"As etapas que o browser realiza para renderizar nossa p\\xE1gina s\\xE3o:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pegar o HTML e come\\xE7ar a criar o Document Object Model. (DOM)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Extrair o CSS e criar o Css Object Model (CSSOM)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Combinar o DOM e CSSOM para criar a \\xE1rvore de renderiza\\xE7\\xE3o. (Rendering tree)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Descobrir onde tudo se encaixa na p\\xE1gina (Layout)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pintar os pixels na tela (Paint)\")), mdx(\"p\", null, \"Tamb\\xE9m temos a etapa de como o browser lida com o javascript, falaremos sobre isso mais \\xE0 frente.\"), mdx(\"h2\", null, \"Convertendo HTML para DOM\"), mdx(\"p\", null, \"Quando acessamos uma p\\xE1gina da web, o browser recebe a resposta da nossa requisi\\xE7\\xE3o (conte\\xFAdo HTML) e transforma em pixels, vamos descobrir como isso \\xE9 feito.\"), mdx(\"p\", null, \"A especifica\\xE7\\xE3o do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HTML\"), \" possui uma s\\xE9rie de regras sobre como o browser deve processar o conte\\xFAdo recebido, por exemplo, o texto contido entre sinais de menor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<\"), \" e maior \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \">\"), \" possui um significado especial no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HTML\"), \", isso deve ser considerado uma \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TAG\"), \", como resultado, toda vez que o browser encontra uma \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TAG\"), \" ele emite um \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Token\"), \", vejamos um exemplo:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<html>\\n  <head>\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width\\\" />\\n    <link href=\\\"style.css\\\" rel=\\\"stylesheet\\\" />\\n\\n    ...\\n  </head>\\n</html>\\n\")), mdx(\"p\", null, \"Ap\\xF3s o browser receber o nosso html ele analisa a primeira \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"TAG\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<html>\"), \" e emite um token, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"existem dois tipos\"), \" de \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokens\"), \" o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StartTag\"), \" e o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EndTag\"), \", nesse caso, o primeiro token \\xE9 o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StartTag: HTML\"), \", o segundo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StartTag: head\"), \" e assim por diante. Esse processo inteiro \\xE9 feito pelo \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tokenizer\"), \" e enquanto o \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tokenizer\"), \" est\\xE1 fazendo esse trabalho, existe outro processo que est\\xE1 consumindo esses tokens e convertendo em \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Node Objects\"), \". Por exemplo: o browser converte o primeiro token \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StartTag: HTML\"), \" e cria o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HTML Node\"), \", depois consome o p\\u0155oximo token e cria o \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node\"), \" correspondente. Perceba que o \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tokenizer\"), \" emite \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Start\"), \" e \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"End\"), \" tokens, que nos mostra a rela\\xE7\\xE3o entre os n\\xF3s (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodes\"), \"). O token \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StartTag: head\"), \" vem antes do token \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EndTag: HTML\"), \" o que nos diz que o token head \\xE9 um filho do token html, nessa l\\xF3gica, vemos que o node da tag \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meta\"), \" e o node da tag \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"link\"), \" s\\xE3o filhos de head, e assim por diante.\"), mdx(\"p\", null, \"Veja um esquema desse processo aplicado \\xE0 uma p\\xE1gina web simples:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/processo-crp.png\",\n    \"alt\": \"Processo do Critical Rendering Path\",\n    \"title\": \"Processo do Critical Rendering Path\"\n  })), mdx(\"p\", null, \"Depois de consumido todos os tokens e todos os nodes criados, chegamos ao DOM, que \\xE9 a estrutura em \\xE1rvore que captura o conte\\xFAdo e propriedades do HTML e todas suas rela\\xE7\\xF5es entre os nodes.\"), mdx(\"p\", null, \"No \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"DevTools\"), \" do navegador \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Google Chrome\"), \" existe uma aba chamada \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Performance\"), \" nela \\xE9 poss\\xEDvel consultar o tempo necess\\xE1rio que o browser levou para executar todo esse processo que vimos acima:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/timeline.png\",\n    \"alt\": \"Timeline\",\n    \"title\": \"Timeline do Google Chrome exibindo o tempo de parse do HTML\"\n  })), mdx(\"p\", null, \"O browser constr\\xF3i o DOM incrementalmente, e n\\xF3s podemos tirar vantagem disso e aumentar a velocidade da renderiza\\xE7\\xE3o. Um exemplo \\xE9 como a p\\xE1gina de resultados do Google trabalha, assim que voc\\xEA est\\xE1 digitando o que quer procurar o servidor do google j\\xE1 entrega o header da p\\xE1gina, que \\xE9 igual para todos os usu\\xE1rios, assim, quando voc\\xEA terminar de escrever o que deseja buscar, o servidor envia os dados em HTML e o browser incrementa o DOM com os resultados. Como voc\\xEA pode notar, o servidor do google n\\xE3o precisa esperar que voc\\xEA envie o que deseja buscar para retornar o HTML completo para o browser processar tudo de uma vez, ele come\\xE7a com o header da p\\xE1gina, e incrementalmente devolve o resultado da sua busca. Portanto, entregar HTML em parcelas \\xE9 algo muito bom!\"), mdx(\"h2\", null, \"CSSOM - Convertendo CSS em CSS Object Model\"), mdx(\"p\", null, \"Bom, o DOM captura o conte\\xFAdo da p\\xE1gina, mas n\\xF3s tamb\\xE9m precisamos saber como exibi-la e onde encaixar as coisas, e para isso, o browser precisa criar o \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CSS Object Model\"), \", o CSSOM \\xE9 bem parecido com o DOM, por\\xE9m, DOM e CSSOM s\\xE3o estruturas independentes! Vejamos:\"), mdx(\"p\", null, \"Quando o navegador est\\xE1 construindo o DOM e encontra uma tag \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"link\"), \" que referencia alguma folha de estilo CSS ele prev\\xEA que esse recurso \\xE9 necess\\xE1rio para renderizar a p\\xE1gina e envia imediatamente uma requisi\\xE7\\xE3o para esse arquivo, segue um exemplo do que essa folha de estilos pode retornar:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-css\"\n  }, \"body {\\n  font-size: 16px;\\n}\\np {\\n  font-weight: bold;\\n}\\nspan {\\n  color: red;\\n}\\np span {\\n  display: none;\\n}\\nimg {\\n  float: right;\\n}\\n\")), mdx(\"p\", null, \"Assim como o \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HTML\"), \" o navegador precisa converter as regras \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CSS\"), \" em algo que ele consiga entender e utilizar. Portanto, o processo feito no HTML \\xE9 repetido, s\\xF3 que dessa vez, para o CSS.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/construcao-cssom.png\",\n    \"alt\": \"CSSOM\",\n    \"title\": \"Contrução do CSSOM\"\n  })), mdx(\"p\", null, \"Como vemos, segue o mesmo padr\\xE3o utilizado no HTML, s\\xF3 que ao inv\\xE9s de criar a estrutura do DOM, \\xE9 criada a estrutura do CSSOM.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/arvore-cssom.png\",\n    \"alt\": \"Árvore CSSOM\",\n    \"title\": \"Árvore CSSOM\"\n  })), mdx(\"p\", null, \"Com o esquema acima, conseguimos entender o porque o CSS \\xE9 aplicado em cascata. O estilo aplicado ao elemento \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body\"), \" \\xE9 herdado por todos os seus filhos, analisando a \\xE1rvore CSS acima, todo texto dentro do elemento \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"span\"), \" ter\\xE1 fonte tamanho 16 pixels (estilo herdado do elemento \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"body\"), \") e a cor vermelha (estilo espec\\xEDfico para o elemento \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"span\"), \").\"), mdx(\"p\", null, \"H\\xE1 um detalhe muito importante, todo navegador possui um conjunto de regras CSS padr\\xF5es, conhecidos tamb\\xE9m por \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"estilos de user-agent\"), \" (por exemplo \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://www.iecss.com/\",\n    \"title\": \"Estilos padrões do Internet Explorer\"\n  }, \"estilos padr\\xF5es do Internet Explorer\"), \")\"), mdx(\"p\", null, \"Assim como \\xE9 poss\\xEDvel descobrir o tempo necess\\xE1rio para o \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"parse\"), \" do HTML, tamb\\xE9m \\xE9 poss\\xEDvel verificar o tempo necess\\xE1rio para o processamento do CSS atrav\\xE9s do DevTools:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/cssom-timeline.png\",\n    \"alt\": \"Timeline do CSSOM\",\n    \"title\": \"Timeline do CSSOM\"\n  })), mdx(\"p\", null, \"\\xC9 poss\\xEDvel analisar o tempo decorrido e tamb\\xE9m quantos elementos foram afetados. Com isso, podemos concluir que escrever um \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CSS de qualidade\"), \", com \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"seletores espec\\xEDficos\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"evitar sobreescritas\"), \" e \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"evitar \", mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"!important\")), \" \\xE9 de grande import\\xE2ncia, devemos afetar apenas os elementos corretos para diminuir o tempo necess\\xE1rio de processamento do CSSOM.\"), mdx(\"p\", null, \"At\\xE9 aqui vimos a constru\\xE7\\xE3o dos modelos de objetos, criamos as \\xE1rvores do DOM e do CSSOM. No entanto, ambos s\\xE3o objetos independentes: um descreve o conte\\xFAdo e o outro, as regras de estilos que devem ser aplicadas ao documento. Para entender a mescla entre o DOM e o CSSOM precisamos conhecer a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\xE1rvore de renderiza\\xE7\\xE3o\")), mdx(\"h2\", null, \"\\xC1rvore de renderiza\\xE7\\xE3o\"), mdx(\"p\", null, \"A primeira tarefa que o browser efetua quando est\\xE1 nessa fase \\xE9 a combina\\xE7\\xE3o do DOM e CSSOM em uma \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\xE1rvore de renderiza\\xE7\\xE3o\"), \" que cont\\xE9m todo conte\\xFAdo \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"vis\\xEDvel\"), \" do DOM e todas regras de \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CSS\"), \" do \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CSSOM\"), \" de cada n\\xF3.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/arvore-de-renderizacao.png\",\n    \"alt\": \"Árvore de renderização\",\n    \"title\": \"Árvore de renderização\"\n  }), \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Exemlo de uma \\xE1rvore de renderiza\\xE7\\xE3o\")), mdx(\"p\", null, \"As demais tarefas s\\xE3o as seguintes:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A partir do come\\xE7o do DOM, percorre cada elemento (n\\xF3) vis\\xEDvel.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Para cada n\\xF3 vis\\xEDvel \\xE9 encontrada e aplicada a sua regra do CSS correspondente.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Por fim, retorna os n\\xF3s vis\\xEDveis e seus estilos aplicados.\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Alguns elementos n\\xE3o s\\xE3o vis\\xEDveis, como \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"head\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"script\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"meta\"), \", etc, e s\\xE3o omitidos pois n\\xE3o s\\xE3o refletidos no resultado da renderiza\\xE7\\xE3o.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Os elementos que forem ocultados via \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"CSS\"), \" tamb\\xE9m s\\xE3o omitidos no resultado da renderiza\\xE7\\xE3o, no exemplo acima, uma das tags \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"span\"), \" est\\xE1 omitida, porque existe uma regra \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"CSS\"), \" que define a propriedade \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"display: none\"), \".\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Observa\\xE7\\xE3o:\"), \" a regra CSS \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"visibility: hidden\"), \" \\xE9 diferente da regra \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"display: none\"), \". A primeira torna o elemento \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"invis\\xEDvel\"), \", o elemento ainda ocupa o seu espa\\xE7o no layout, ou seja, \\xE9 renderizado como uma caixa vazia. O segundo remove completamente o elemento da \\xE1rvore de renderiza\\xE7\\xE3o, o elemento fica invis\\xEDvel e \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"n\\xE3o faz parte do layout\"), \".\"), mdx(\"p\", null, \"Por fim, temos o resultado da renderiza\\xE7\\xE3o com o conte\\xFAdo e toda informa\\xE7\\xE3o de estilo do conte\\xFAdo vis\\xEDvel na tela. Podemos passar para fase de \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"layout\"), \".\"), mdx(\"h3\", null, \"Layout\"), mdx(\"p\", null, \"At\\xE9 agora o browser calculou quais n\\xF3s devem ser vis\\xEDveis e processou seus estilos. O browser precisa agora calcular a posi\\xE7\\xE3o e o tamanho que ir\\xE1 ocupar no \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"viewport\"), \" (espa\\xE7o dispon\\xEDvel do dispositivo), essa fase \\xE9 o \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"layout\"), \", tamb\\xE9m conhecida como \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"reflow\"), \".\"), mdx(\"p\", null, \"Para calcular a posi\\xE7\\xE3o e o tamanho exato de cada elemento, o browser analisa a \\xE1rvore de renderiza\\xE7\\xE3o passando por toda ela a partir de sua raiz. Vamos analisar esse simples exemplo:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html\"\n  }, \"<html>\\n  <head>\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width,initial-scale=1\\\" />\\n    <title>Critial Path: Hello world!</title>\\n  </head>\\n  <body>\\n    <div style=\\\"width: 50%\\\">\\n      <div style=\\\"width: 50%\\\">Hello world!</div>\\n    </div>\\n  </body>\\n</html>\\n\")), mdx(\"p\", null, \"O \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HTML\"), \" acima possu\\xED dois divs aninhados. O primeiro (pai) define o tamanho do elemento na tela como 50% da largura da janela do dispositivo (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"viewport\"), \"). O segundo div (filho) define sua largura como 50% do seu pai, ou seja, 25% da largura do \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"viewport\"), \".\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/layout-viewport.png\",\n    \"alt\": \"Layout viewport\",\n    \"title\": \"Layout viewport\"\n  })), mdx(\"p\", null, \"O resultado da renderiza\\xE7\\xE3o \\xE9 em modelo de caixa, ou seja, todos elementos s\\xE3o ret\\xE2ngulos. Todas as medidas relativas, como porcentagens, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"em\\u2019s\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"rem\\u2019s\"), \", etc s\\xE3o convertidas em pixels absolutos na tela.\"), mdx(\"p\", null, \"Agora que o browser possui todos os n\\xF3s vis\\xEDveis, seus estilos aplicados e sua geometria, finalmente chega a \\xFAltima fase, essa etapa \\xE9 chamada de \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Paint\"), \".\"), mdx(\"h3\", null, \"Paint\"), mdx(\"p\", null, \"O paint \\xE9 o processo que o browser executa para aplicar cada n\\xF3 da \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\xE1rvore de renderiza\\xE7\\xE3o\"), \" em pixeis reais na tela do dispositivo do usu\\xE1rio.\\nAssim como os outros processos, no \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DevTools\"), \" do \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Chrome\"), \", tamb\\xE9m \\xE9 poss\\xEDvel examinar o tempo necess\\xE1rio para a fase de \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Layout\"), \" e \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Paint\"), \".\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/paint-timeline.png\",\n    \"alt\": \"Layout Timeline\",\n    \"title\": \"Layout Timeline\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"O evento \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"layout\"), \" captura exibe o tempo e a quantidade de n\\xF3s que foram constru\\xEDdos, posicionados e tiveram seu tamanho calculado a partir da \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"\\xE1rvore de renderiza\\xE7\\xE3o\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Assim que o layout termina, o browser emite eventos de \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Paint setup\"), \" e \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Paint\"), \", esses eventos convertem a \\xE1rvore de renderiza\\xE7\\xE3o em pixeis na tela.\")), mdx(\"p\", null, \"O tempo nececss\\xE1rio para executar essa renderiza\\xE7\\xE3o varia de acordo com a quantidade de elementos que temos em nosso \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"HTML\"), \", da complexidade do \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"CSS\"), \" e do tamanho do viewport do dispositivo. Quanto maior o HTML, maior trabalho para o navegador. Quanto mais complexo o estilo, mais tempo \\xE9 necess\\xE1rio na etapa de \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Paint\"), \". Fazer a renderiza\\xE7\\xE3o de uma cor s\\xF3lida (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#000\"), \") \\xE9 pouco custosa, por\\xE9m, a renderiza\\xE7\\xE3o de uma sombra (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"box-shadow\"), \") \\xE9 bem mais complexa e custosa.\"), mdx(\"p\", null, \"E com isso descobrimos todo o trabalho que o browser necessita realizar para renderizar nossa p\\xE1gina na tela do usu\\xE1rio. No pr\\xF3ximo post veremos o que gera o famoso \\u201CBloqueio de renderiza\\xE7\\xE3o\\u201D ou \\u201CBloqueio do caminho crit\\xEDco de renderiza\\xE7\\xE3o\\u201D e como podemos com medidas simples, solucionar isso.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Todas imagens foram retiradas do \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developers.google.com/\",\n    \"title\": \"Google Developers\"\n  }, \"Google Developers\"))));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":2,"value":"Caminho crítico de renderização"},{"depth":2,"value":"Convertendo HTML para DOM"},{"depth":2,"value":"CSSOM - Convertendo CSS em CSS Object Model"},{"depth":2,"value":"Árvore de renderização"}]}},"pageContext":{"slug":"/critical-rendering-path/"}},
    "staticQueryHashes": ["3128451518"]}