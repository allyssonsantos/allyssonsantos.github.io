---
title: Arrow Functions
layout: post
category: Javascript
meta: Veja como funcionam as arrows functions introduzidas no ES6! Entenda sua sintaxe e como se comporta o valor de this.
excerpt: Entenda como funcionam as arrows functions, incluida na nova especificação do JavaScript (ES6).
preview-img: arrows.jpg
comments: true
author: Allysson dos Santos
---
<span class="small" itemscope="itemscope" itemtype="https://schema.org/TechArticle">Nível: <span itemprop="Beginner">iniciante</span></span>

<h2>Introdução</h2>
<p>Arrow function é uma nova forma de se escrever <strong>funções anonimas</strong>, vamos entender sua sintaxe e como funciona o seu valor de <code class="code-piece">this</code>.</p>
<h3>Sintaxe</h3>
<p>Uma função anonima no ES5 era assim:</p>
{% highlight js linenos %}
var paises = ['Alemanha', 'Estados Unidos'];
var irei = paises.map(function(pais) {
  return 'Um dia irei para ' + pais;
});
console.log(irei);
> ["Um dia irei para Alemanha", "Um dia irei para Estados Unidos"]
{% endhighlight %}
<p>Com as arrows functions, podemos simplifica-las das seguintes formas:</p>
{% highlight js linenos %}
var paises = ['Alemanha', 'Estados Unidos'];
const ireiSemFunction = paises.map((pais) => {
  return 'Um dia irei para ' + pais;
}); // Podemos tirar a palavra function e adicionar uma => a frente dos () dos parametros.

const ireiComUmParametro = paises.map(pais => {
  return 'Um dia irei para ' + pais;
}); // Caso a função tenha apenas um parâmetro, podemos retirar o seus parênteses.

const ireiEmUmaLinha = paises.map(pais => 'Um dia irei para ' + pais);
/* Caso a função tenha apenas um parâmetro e retorne logo na primeira linha,
podemos escrever sem as chaves e sem a palavra return */
{% endhighlight %}
<p>Recapitulando:</p>
<ul>
	<li>Podemos tirar a palavra function e adicionar uma seta <code class="code-piece">=></code> em frente os parênteses dos parâmetros.</li>
	<li>Se a sua função anonima tiver apenas um parâmetro, pode <strong>retirar</strong> seus parênteses.</li>
	<li>Se a função não tiver parâmetros, podemos deixar <code class="code-piece">()</code> vazio mesmo.</li>
	<li>Se a função der um <code class="code-piece">return</code> na primeira linha, podemos escrever apenas em uma linha, sem chaves e sem a palavra <code class="code-piece">return</code>.</li>
</ul>
<h3>Objeto this</h3>
<p>O <strong>this</strong> dentro de uma <em>arrow function</em> se comporta de uma maneira diferente da que estamos acostumados, primeiro, vamos analisar um código javascript <strong>sem uso de arrow functions</strong>.</p>

<p>Imagine que temos o seguinte HTML e JS:</p>

{% highlight html linenos %}
<html>
<body>
  <button id="btn">Click!</button>
</body>
<script>
  var btn = document.getElementById('btn');

  btn.addEventListener('click', function () {
    console.log(this)
  });
</script>
</html>
{% endhighlight %}
<p>Na função acima, ao clicar no botão com <code class="code-piece">id='btn'</code> iremos logar o valor de <strong>this</strong>, que nesse caso é o próprio botão. Teremos como saída essa resposta:</p>
{% highlight html linenos %}
<button id="btn">Click</button>
{% endhighlight %}
<p>Se esse mesmo código for escrito com <em>arrow function</em> o resultado não será o mesmo, pois o valor de <code class="code-piece">this</code> não está referenciado ao botão que está acontecendo a ação, ele está referenciado a <strong>todo o contexto</strong> que a função está inserida, no nosso caso, o contexto é a <em>window</em>.</p>
<p>Ao clicar no botão com uma <strong>arrow function</strong>, teremos o seguinte retorno:</p>
{% highlight html linenos %}
<html>
<body>
  <button id="btn">Click!</button>
</body>
<script>
  var btn = document.getElementById('btn');

  btn.addEventListener('click', () => { // <-- mudança aqui
    console.log(this)
  });
</script>
</html>
--------------------------
> Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage,
 sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
{% endhighlight %}

<p>Agora um outro exemplo para tentar fixar melhor, temos a seguinte estrutura sem o uso de arrow functions ainda:</p>
{% highlight html linenos %}
<html>
<body>
  <button id="btn">Click!</button>
</body>
<script>
  var pessoa = {
    nome: 'Allysson',
    idade: '22',

    apresentar: function () {
      return `Meu nome e ${this.nome} e eu tenho ${this.idade} anos`;
    },

    falar: function () {
      var self = this;
      window.setTimeout(function() {
        console.log(self.apresentar());
      }, 500);
    }
  };

  var btn = document.getElementById('btn');

  btn.addEventListener('click', function() {
    pessoa.falar();
  });
</script>
</html>
{% endhighlight %}
<p>Repare que na linha 15 precisamos <strong>guardar o valor de this</strong> na variável <code class="code-piece">self</code> <em>(nesse moemento o valor de this é o próprio objeto pessoa)</em>, se usássemos diretamente o <code class="code-piece">this</code> dentro do <code class="code-piece">console.log</code> que está no <code class="code-piece">setTimeout</code> acabaríamos nos referênciando a <em>window</em>, e dentro da <em>window</em> não possuímos a função falar, ela está dentro de <code class="code-piece">pessoa</code>.</p>
<p>Executando esse JS temos o seguinte log no console:</p>
{% highlight js linenos %}
> Meu nome e Allysson e eu tenho 22 anos
{% endhighlight %}
<h4>Usando arrow functions</h4>
<p>Agora se nós mudarmos a função anonima que está dentro do <code class="code-piece">setTimeout</code> para utilizar <em>arrow function</em>, <strong>não precisaremos guardar o valor de this</strong> dentro de <code class="code-piece">self</code>, pois como é uma <em>arrow function</em>, o contexto de this já é o objeto pessoa, <strong>o escopo se mantém o mesmo</strong>!</p>
{% highlight html linenos %}
<html>
<body>
  <button id="btn">Click!</button>
</body>
<script>
  var pessoa = {
    nome: 'Allysson',
    idade: '22',

    apresentar: function () {
      return `Meu nome e ${this.nome} e eu tenho ${this.idade} anos`;
    },

    falar: function () {
      window.setTimeout(() => {
        console.log(this.apresentar());
      }, 500);
    }
  };

  var btn = document.getElementById('btn');

  btn.addEventListener('click', function() {
    pessoa.falar();
  });
</script>
</html>
{% endhighlight %}
<p>Temos como retorno o mesmo que na função anterior, mas agora <strong>sem precisar do self</strong>!</p>
{% highlight js linenos %}
> Meu nome e Allysson e eu tenho 22 anos
{% endhighlight %}
<h2>Conclusão</h2>
<p>O valor de this com arrow functions pode gerar grandes dores de cabeça, esteja atento, faça testes, pratique criando funções anonimas convencionais e logue o valor de this, faça essa mesma função utilizando arrow functions e compare o valor de this, <strong>saiba que o escopo se mantem o mesmo de onde a arrow function foi criada</strong>!</p>
<p>Ela é muito boa para ocasiões como no objeto pessoa, mas não parece ser muito interessante quando queremos adicionar um event listener em algum elemento, pois estariamos alterando o escopo, o contexto. Nosso event listener não teria o efeito desejado.</p>